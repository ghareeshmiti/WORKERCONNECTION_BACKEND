
import 'dotenv/config';
import pg from 'pg';
import Database from 'better-sqlite3';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const { Pool } = pg;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// 1. Setup Connections
const sqlitePath = path.join(__dirname, 'fido.db');
if (!fs.existsSync(sqlitePath)) {
    console.error('SQLite database not found!');
    process.exit(1);
}

const sqlite = new Database(sqlitePath);
const pgPool = new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: { rejectUnauthorized: false }
});

async function migrate() {
    const client = await pgPool.connect();
    try {
        console.log('Connected to Supabase Postgres!');

        // 2. Create Schema (Postgres compatible)
        console.log('Creating schema...');
        await client.query('BEGIN');

        await client.query(`
            CREATE TABLE IF NOT EXISTS users (
                username TEXT PRIMARY KEY,
                id BYTEA NOT NULL,
                "currentChallenge" TEXT
            );
        `);

        await client.query(`
            CREATE TABLE IF NOT EXISTS authenticators (
                "credentialID" BYTEA NOT NULL PRIMARY KEY,
                username TEXT NOT NULL,
                "credentialPublicKey" BYTEA NOT NULL,
                counter INTEGER NOT NULL,
                transports TEXT,
                FOREIGN KEY(username) REFERENCES users(username)
            );
        `);

        await client.query(`
            CREATE TABLE IF NOT EXISTS checks (
                username TEXT PRIMARY KEY,
                status TEXT NOT NULL,
                timestamp TEXT,
                FOREIGN KEY(username) REFERENCES users(username)
            );
        `);

        await client.query(`
            CREATE TABLE IF NOT EXISTS audit_logs (
                id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                username TEXT NOT NULL,
                action TEXT NOT NULL,
                timestamp TEXT NOT NULL,
                location TEXT,
                FOREIGN KEY(username) REFERENCES users(username)
            );
        `);

        await client.query(`
            CREATE TABLE IF NOT EXISTS stations (
                name TEXT PRIMARY KEY,
                description TEXT,
                created_at TEXT
            );
        `);

        await client.query('COMMIT');
        console.log('Schema created successfully.');

        // 3. Migrate Data
        console.log('Migrating data...');

        // Users
        const users = sqlite.prepare('SELECT * FROM users').all();
        console.log(`Found ${users.length} users.`);
        for (const user of users) {
            await client.query(
                'INSERT INTO users (username, id, "currentChallenge") VALUES ($1, $2, $3) ON CONFLICT (username) DO NOTHING',
                [user.username, user.id, user.currentChallenge]
            );
        }

        // Authenticators
        const auths = sqlite.prepare('SELECT * FROM authenticators').all();
        console.log(`Found ${auths.length} authenticators.`);
        for (const auth of auths) {
            await client.query(
                `INSERT INTO authenticators ("credentialID", username, "credentialPublicKey", counter, transports) 
                 VALUES ($1, $2, $3, $4, $5) ON CONFLICT ("credentialID") DO NOTHING`,
                [auth.credentialID, auth.username, auth.credentialPublicKey, auth.counter, auth.transports]
            );
        }

        // Checks
        const checks = sqlite.prepare('SELECT * FROM checks').all();
        console.log(`Found ${checks.length} check entries.`);
        for (const check of checks) {
            await client.query(
                'INSERT INTO checks (username, status, timestamp) VALUES ($1, $2, $3) ON CONFLICT (username) DO UPDATE SET status = $2, timestamp = $3',
                [check.username, check.status, check.timestamp]
            );
        }

        // Audit Logs
        const logs = sqlite.prepare('SELECT * FROM audit_logs').all();
        console.log(`Found ${logs.length} audit logs.`);
        for (const log of logs) {
            await client.query(
                'INSERT INTO audit_logs (username, action, timestamp, location) VALUES ($1, $2, $3, $4)',
                [log.username, log.action, log.timestamp, log.location]
            );
        }

        // Stations
        const stations = sqlite.prepare('SELECT * FROM stations').all();
        console.log(`Found ${stations.length} stations.`);
        for (const st of stations) {
            await client.query(
                'INSERT INTO stations (name, description, created_at) VALUES ($1, $2, $3) ON CONFLICT (name) DO NOTHING',
                [st.name, st.description, st.created_at || new Date().toISOString()]
            );
        }

        console.log('Data migration complete!');

    } catch (e) {
        await client.query('ROLLBACK');
        console.error('Migration failed:', e);
    } finally {
        client.release();
        pgPool.end();
    }
}

migrate();
